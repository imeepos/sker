
## 最佳实践

### 1. 组件命名规范

```typescript
// ✅ 好的命名
export function AgentCreationDialog() {}
export function MessageListItem() {}
export function DatabaseConnectionStatus() {}

// ❌ 避免的命名
export function Dialog() {}
export function Item() {}
export function Status() {}
```

### 2. Props 类型定义

```typescript
// ✅ 明确的 Props 类型
interface AgentCardProps {
  agent: Agent
  onEdit?: (agent: Agent) => void
  onDelete?: (agentId: string) => void
  className?: string
  isSelected?: boolean
}

// ❌ 过于宽泛的类型
interface Props {
  data: any
  onClick: Function
}
```

### 3. 条件渲染

```typescript
// ✅ 使用组件进行条件渲染
function AgentList({ agents }: { agents: Agent[] }) {
  if (agents.length === 0) {
    return <EmptyState message="暂无智能体" />
  }

  return (
    <div className="grid gap-4">
      {agents.map((agent) => (
        <AgentCard key={agent.id} agent={agent} />
      ))}
    </div>
  )
}

// ❌ 复杂的内联条件
function AgentList({ agents }: { agents: Agent[] }) {
  return (
    <div>
      {agents.length === 0 ? (
        <div className="text-center p-8">
          <div className="text-muted-foreground">暂无智能体</div>
        </div>
      ) : (
        <div className="grid gap-4">
          {agents.map((agent) => (
            <AgentCard key={agent.id} agent={agent} />
          ))}
        </div>
      )}
    </div>
  )
}
```

### 4. 错误边界

```typescript
// src/shared/components/ui/ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react'
import { Button } from '@/shared/components/ui/button'
import { AlertTriangle } from 'lucide-react'

interface Props {
  children: ReactNode
  fallback?: ReactNode
}

interface State {
  hasError: boolean
  error?: Error
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('组件错误:', error, errorInfo)
  }

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback
      }

      return (
        <div className="flex flex-col items-center justify-center p-8 text-center">
          <AlertTriangle className="h-12 w-12 text-destructive mb-4" />
          <h2 className="text-lg font-semibold mb-2">出现了错误</h2>
          <p className="text-muted-foreground mb-4">
            {this.state.error?.message || '未知错误'}
          </p>
          <Button
            onClick={() => this.setState({ hasError: false, error: undefined })}
          >
            重试
          </Button>
        </div>
      )
    }

    return this.props.children
  }
}
```

### 5. 可访问性

```typescript
// ✅ 良好的可访问性
function SearchInput({ onSearch }: { onSearch: (query: string) => void }) {
  const [query, setQuery] = useState('')

  return (
    <div className="relative">
      <label htmlFor="search" className="sr-only">
        搜索智能体
      </label>
      <Input
        id="search"
        type="search"
        placeholder="搜索智能体..."
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        onKeyDown={(e) => {
          if (e.key === 'Enter') {
            onSearch(query)
          }
        }}
        aria-describedby="search-description"
      />
      <div id="search-description" className="sr-only">
        输入智能体名称或描述进行搜索
      </div>
    </div>
  )
}
```