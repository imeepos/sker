# TypeScript 绑定生成器实现原理

这个工具基于 **ts-rs** 库来实现 Rust 到 TypeScript 的类型绑定生成，整个过程分为以下几个步骤：

## 核心实现原理

### 1. 使用 `ts-rs` 库的 derive 宏

所有需要生成 TypeScript 类型的 Rust 结构体都使用了 `#[derive(TS)]` 宏：

```rust
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Hash, Serialize, Deserialize, Display, TS)]
pub enum AskForApproval {
    UnlessTrusted,
    // ...
}
```

`ts-rs` 库会在编译时自动为这些类型生成对应的 TypeScript 类型定义。

### 2. 批量导出类型

在 `lib.rs` 中，通过调用每个类型的 `export_all_to()` 方法来生成 TypeScript 文件：

```rust
// 导出所有相关类型到指定目录
mcp_types::InitializeResult::export_all_to(out_dir)?;
codex_protocol::mcp_protocol::ConversationId::export_all_to(out_dir)?;
codex_protocol::mcp_protocol::InputItem::export_all_to(out_dir)?;
// ... 更多类型
```

每个 `export_all_to()` 调用会：
- 为该类型生成单独的 `.ts` 文件
- 包含该类型的所有依赖类型
- 使用适当的 TypeScript 语法

### 3. 生成统一的索引文件

`generate_index_ts()` 函数会：
- 扫描输出目录中的所有 `.ts` 文件
- 生成一个 `index.ts` 文件，重新导出所有类型：

```typescript
// 生成的 index.ts 示例
export type { ConversationId } from "./ConversationId";
export type { InputItem } from "./InputItem";
export type { ClientRequest } from "./ClientRequest";
// ...
```

### 4. 添加文件头和格式化

- **添加标识头**：为每个生成的文件添加 `"// GENERATED CODE! DO NOT MODIFY BY HAND!"` 标识
- **代码格式化**：可选使用 Prettier 格式化生成的 TypeScript 文件

## 关键技术细节

### ts-rs 库的工作原理

1. **编译时代码生成**：`ts-rs` 在 Rust 编译时分析结构体定义
2. **类型映射**：自动将 Rust 类型映射到对应的 TypeScript 类型
3. **依赖解析**：自动处理类型之间的依赖关系

### 类型映射示例

```rust
// Rust 枚举
#[derive(TS)]
pub enum Status {
    Pending,
    Completed,
}

// 生成的 TypeScript
export type Status = "Pending" | "Completed";
```

```rust
// Rust 结构体
#[derive(TS)]
pub struct User {
    pub id: u64,
    pub name: String,
    pub status: Status,
}

// 生成的 TypeScript
export interface User {
    id: number;
    name: string;
    status: Status;
}
```

## 实现流程

1. **类型标记**：在 Rust 代码中为需要导出的类型添加 `#[derive(TS)]`
2. **编译时生成**：`ts-rs` 在编译时分析类型定义并生成 TypeScript 代码
3. **批量导出**：调用 `export_all_to()` 方法将类型导出到指定目录
4. **文件处理**：添加文件头标识，生成索引文件
5. **代码格式化**：使用 Prettier 格式化生成的代码

## 优势

1. **类型安全**：确保 Rust 和 TypeScript 之间的类型一致性
2. **自动化**：无需手动维护 TypeScript 类型定义
3. **同步更新**：Rust 类型变更时，TypeScript 类型会自动更新
4. **依赖管理**：自动处理复杂的类型依赖关系
5. **开发效率**：减少手动同步类型定义的工作量

## 适用场景

这种方法特别适合需要在 Rust 后端和 TypeScript 前端之间保持严格类型一致性的项目，例如：

- API 接口定义
- 配置文件结构
- 消息协议
- 数据模型

通过自动化的类型生成，可以大大减少因类型不一致导致的运行时错误。